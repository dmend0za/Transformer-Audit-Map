<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Audit Map - Dynamic Configuration</title>
    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <style>
        /* Basic styling for the body and map container */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        
        #unsupported {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: #f8f8f8;
            flex-direction: column;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Styling for the popups */
        .mapboxgl-popup {
            max-width: 250px;
            font-size: 14px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .mapboxgl-popup-content {
            padding: 15px;
            border-radius: 8px;
        }

        .mapboxgl-popup-content h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-weight: 600;
        }

        .mapboxgl-popup-content p {
            margin: 0;
            color: #555;
        }

        .mapboxgl-popup-content a {
            color: #007bff;
            text-decoration: none;
            font-weight: bold;
            display: inline-block;
            margin-top: 10px;
        }

        .mapboxgl-popup-content a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<div id="map"></div>
<div id="loading">
    <h3>Loading tileset configurations...</h3>
    <p>Fetching MapBox source layer metadata...</p>
</div>
<div id="unsupported">
    <h2>Map Display Error</h2>
    <p>Sorry, your browser or environment does not support WebGL, which is required to view this map.</p>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Hide the unsupported message by default
        document.getElementById('unsupported').style.display = 'none';

        // Check if Mapbox GL is supported in the current browser/environment.
        if (mapboxgl.supported()) {
            // --- MAPBOX INITIALIZATION ---
            mapboxgl.accessToken = 'pk.eyJ1IjoiZmllbGRzZW5zZSIsImEiOiJjbWMwb2ljY3YwNGFoMnJvaXN5c2xnMnR6In0.wc3C3TrsgsfyLf5ZJqHpnA';

            // Initialize the map with a standard Mapbox style.
            const map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/light-v11',
                center: [-77.9153, 35.7218], // Center coordinates for Wilson, NC
                zoom: 11.5,
                failIfMajorPerformanceCaveat: false
            });

            // Configuration for your tilesets
            const tilesetConfigs = [
                {
                    sourceId: 'transformers',
                    tilesetId: 'fieldsense.4s90abve',
                    url: 'mapbox://fieldsense.4s90abve'
                },
                {
                    sourceId: 'meters',
                    tilesetId: 'fieldsense.4hey26iq',
                    url: 'mapbox://fieldsense.4hey26iq'
                },
                {
                    sourceId: 'secondary-oh',
                    tilesetId: 'fieldsense.c53vz8g4',
                    url: 'mapbox://fieldsense.c53vz8g4'
                },
                {
                    sourceId: 'secondary-ug',
                    tilesetId: 'fieldsense.2hebp65r',
                    url: 'mapbox://fieldsense.2hebp65r'
                }
            ];

            // Function to fetch tileset metadata
            async function fetchTilesetMetadata(tilesetId) {
                try {
                    const response = await fetch(`https://api.mapbox.com/v4/${tilesetId}.json?access_token=${mapboxgl.accessToken}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching metadata for ${tilesetId}:`, error);
                    return null;
                }
            }

            // Function to fetch tileset recipe (if available)
            async function fetchTilesetRecipe(tilesetId) {
                try {
                    const response = await fetch(`https://api.mapbox.com/tilesets/v1/${tilesetId}/recipe?access_token=${mapboxgl.accessToken}`);
                    if (!response.ok) {
                        // Recipe might not be available for all tilesets (especially uploaded ones)
                        console.log(`Recipe not available for ${tilesetId}`);
                        return null;
                    }
                    return await response.json();
                } catch (error) {
                    console.log(`Recipe not available for ${tilesetId}:`, error.message);
                    return null;
                }
            }

            // Function to create layer configurations from MapBox metadata
            function createLayerConfigFromMetadata(sourceId, tilesetMetadata, recipe) {
                const layers = [];
                
                if (!tilesetMetadata || !tilesetMetadata.vector_layers) {
                    console.warn(`No vector layers found for ${sourceId}`);
                    return layers;
                }

                tilesetMetadata.vector_layers.forEach(vectorLayer => {
                    const layerConfig = {
                        sourceId: sourceId,
                        sourceLayer: vectorLayer.id,
                        fields: vectorLayer.fields || {},
                        description: vectorLayer.description || '',
                        minzoom: vectorLayer.minzoom || tilesetMetadata.minzoom || 0,
                        maxzoom: vectorLayer.maxzoom || tilesetMetadata.maxzoom || 22
                    };

                    // Apply recipe configurations if available
                    if (recipe && recipe.recipe && recipe.recipe.layers) {
                        const recipeLayer = recipe.recipe.layers[vectorLayer.id];
                        if (recipeLayer) {
                            layerConfig.minzoom = recipeLayer.minzoom || layerConfig.minzoom;
                            layerConfig.maxzoom = recipeLayer.maxzoom || layerConfig.maxzoom;
                            layerConfig.recipeConfig = recipeLayer;
                        }
                    }

                    layers.push(layerConfig);
                });

                return layers;
            }

            // Function to determine appropriate styling based on layer metadata
            function getLayerStyling(layerConfig, sourceId) {
                const sourceLayer = layerConfig.sourceLayer;
                const fields = layerConfig.fields;

                // Apply styling based on source and layer characteristics
                if (sourceId === 'transformers') {
                    if (fields.SUBTYPEC_1) {
                        return [
                            {
                                'id': `${sourceLayer}-underground`,
                                'type': 'circle',
                                'filter': ['==', 'SUBTYPEC_1', 'Underground Transformer'],
                                'paint': { 
                                    'circle-color': '#2E8B57', 
                                    'circle-radius': 7, 
                                    'circle-stroke-width': 1.5, 
                                    'circle-stroke-color': '#ffffff' 
                                }
                            },
                            {
                                'id': `${sourceLayer}-overhead`,
                                'type': 'circle',
                                'filter': ['!=', 'SUBTYPEC_1', 'Underground Transformer'],
                                'paint': { 
                                    'circle-color': '#808080', 
                                    'circle-radius': 6, 
                                    'circle-stroke-width': 1.5, 
                                    'circle-stroke-color': '#ffffff' 
                                }
                            }
                        ];
                    }
                } else if (sourceId === 'meters') {
                    return [{
                        'id': `${sourceLayer}-points`,
                        'type': 'circle',
                        'paint': { 
                            'circle-color': '#1E90FF', 
                            'circle-radius': 5, 
                            'circle-stroke-width': 1, 
                            'circle-stroke-color': '#ffffff' 
                        }
                    }];
                } else if (sourceId === 'secondary-oh') {
                    return [{
                        'id': `${sourceLayer}-lines`,
                        'type': 'line',
                        'layout': { 'line-join': 'round', 'line-cap': 'round' },
                        'paint': { 'line-color': '#555555', 'line-width': 2 }
                    }];
                } else if (sourceId === 'secondary-ug') {
                    return [{
                        'id': `${sourceLayer}-lines`,
                        'type': 'line',
                        'layout': { 'line-join': 'round', 'line-cap': 'round' },
                        'paint': { 'line-color': '#ff8c00', 'line-width': 2, 'line-dasharray': [2, 2] }
                    }];
                }

                // Default styling
                return [{
                    'id': `${sourceLayer}-default`,
                    'type': 'circle',
                    'paint': { 'circle-color': '#666666', 'circle-radius': 4 }
                }];
            }

            // Main function to load and configure map
            async function loadMapWithDynamicConfig() {
                try {
                    console.log('Fetching tileset configurations...');
                    
                    // Fetch metadata and recipes for all tilesets
                    const configPromises = tilesetConfigs.map(async config => {
                        const [metadata, recipe] = await Promise.all([
                            fetchTilesetMetadata(config.tilesetId),
                            fetchTilesetRecipe(config.tilesetId)
                        ]);
                        
                        return {
                            ...config,
                            metadata,
                            recipe,
                            layers: createLayerConfigFromMetadata(config.sourceId, metadata, recipe)
                        };
                    });

                    const enrichedConfigs = await Promise.all(configPromises);
                    
                    console.log('Tileset configurations loaded:', enrichedConfigs);

                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    map.on('load', () => {
                        // Add sources
                        enrichedConfigs.forEach(config => {
                            if (config.metadata) {
                                map.addSource(config.sourceId, {
                                    type: 'vector',
                                    url: config.url
                                });
                                console.log(`Added source: ${config.sourceId}`);
                            }
                        });

                        // Add layers based on dynamic configuration
                        const interactiveLayers = [];
                        
                        enrichedConfigs.forEach(config => {
                            if (!config.layers || config.layers.length === 0) return;

                            config.layers.forEach(layerConfig => {
                                const layerStyles = getLayerStyling(layerConfig, config.sourceId);
                                
                                layerStyles.forEach(style => {
                                    const layerDef = {
                                        ...style,
                                        'source': config.sourceId,
                                        'source-layer': layerConfig.sourceLayer,
                                        'minzoom': layerConfig.minzoom,
                                        'maxzoom': layerConfig.maxzoom
                                    };

                                    map.addLayer(layerDef);
                                    interactiveLayers.push(style.id);
                                    console.log(`Added layer: ${style.id} from source-layer: ${layerConfig.sourceLayer}`);
                                });
                            });
                        });

                        // Add interactivity
                        setupInteractivity(interactiveLayers);
                    });

                } catch (error) {
                    console.error('Error loading map configuration:', error);
                    document.getElementById('loading').innerHTML = '<h3>Error loading configuration</h3><p>Failed to fetch tileset metadata. Using fallback configuration.</p>';
                    
                    // Fallback to your original configuration
                    loadFallbackConfiguration();
                }
            }

            // Fallback configuration (your original setup)
            function loadFallbackConfiguration() {
                document.getElementById('loading').style.display = 'none';
                
                map.on('load', () => {
                    // Add your original sources and layers here as fallback
                    map.addSource('transformers', {
                        type: 'vector',
                        url: 'mapbox://fieldsense.4s90abve' 
                    });

                    map.addSource('meters', {
                        type: 'vector',
                        url: 'mapbox://fieldsense.4hey26iq'
                    });

                    map.addSource('secondary-oh', {
                        type: 'vector',
                        url: 'mapbox://fieldsense.c53vz8g4'
                    });

                    map.addSource('secondary-ug', {
                        type: 'vector',
                        url: 'mapbox://fieldsense.2hebp65r'
                    });

                    // Add your original layers
                    map.addLayer({
                        'id': 'ug-feeders',
                        'type': 'line',
                        'source': 'secondary-ug',
                        'source-layer': 'secondary_UG-0ox1k5', 
                        'layout': { 'line-join': 'round', 'line-cap': 'round' },
                        'paint': { 'line-color': '#ff8c00', 'line-width': 2, 'line-dasharray': [2, 2] }
                    });

                    map.addLayer({
                        'id': 'oh-feeders',
                        'type': 'line',
                        'source': 'secondary-oh',
                        'source-layer': 'secondary_OH-27459y', 
                        'layout': { 'line-join': 'round', 'line-cap': 'round' },
                        'paint': { 'line-color': '#555555', 'line-width': 2 }
                    });

                    map.addLayer({
                        'id': 'transformers-underground',
                        'type': 'circle',
                        'source': 'transformers',
                        'source-layer': 'transformer_bank-3t7yaf', 
                        'filter': ['==', 'SUBTYPEC_1', 'Underground Transformer'],
                        'paint': { 'circle-color': '#2E8B57', 'circle-radius': 7, 'circle-stroke-width': 1.5, 'circle-stroke-color': '#ffffff' }
                    });

                    map.addLayer({
                        'id': 'transformers-overhead',
                        'type': 'circle',
                        'source': 'transformers',
                        'source-layer': 'transformer_bank-3t7yaf', 
                        'filter': ['!=', 'SUBTYPEC_1', 'Underground Transformer'],
                        'paint': { 'circle-color': '#808080', 'circle-radius': 6, 'circle-stroke-width': 1.5, 'circle-stroke-color': '#ffffff' }
                    });
                    
                    map.addLayer({
                        'id': 'electric-meters',
                        'type': 'circle',
                        'source': 'meters',
                        'source-layer': 'electric_meters-5xjegj', 
                        'paint': { 'circle-color': '#1E90FF', 'circle-radius': 5, 'circle-stroke-width': 1, 'circle-stroke-color': '#ffffff' }
                    });

                    setupInteractivity(['transformers-underground', 'transformers-overhead', 'electric-meters']);
                });
            }

            // Setup popup interactivity
            function setupInteractivity(interactiveLayers) {
                const popup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                const createTransformerPopup = (e) => {
                    const properties = e.features[0].properties;
                    const coordinates = e.features[0].geometry.coordinates.slice();
                    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                    }
                    const popupHTML = `
                        <h4>Transformer Details</h4>
                        <p><strong>ID:</strong> ${properties.OBJECTID || 'N/A'}</p>
                        <p><strong>Feeder:</strong> ${properties.FEEDERID || 'N/A'}</p>
                        <p><strong>KVA:</strong> ${properties.BANKKVA || 'N/A'}</p>
                        <p><strong>Type:</strong> ${properties.SUBTYPEC_1 || 'N/A'}</p>
                        <p><strong>Comments:</strong> ${properties.COMMENTS_C || 'N/A'}</p>
                        <a href="${properties.Link}" target="_blank">Open Audit Form &rarr;</a>
                    `;
                    popup.setLngLat(coordinates).setHTML(popupHTML).addTo(map);
                };
                
                const createMeterPopup = (e) => {
                    const properties = e.features[0].properties;
                    const coordinates = e.features[0].geometry.coordinates.slice();
                    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                    }
                    const popupHTML = `
                        <h4>Electric Meter</h4>
                        <p><strong>Meter Number:</strong> ${properties.MTRNUM || 'N/A'}</p>
                        <p><strong>Feeder:</strong> ${properties.FEEDERID || 'N/A'}</p>
                    `;
                    popup.setLngLat(coordinates).setHTML(popupHTML).addTo(map);
                };

                // Add click listeners for each interactive layer
                interactiveLayers.forEach(layerId => {
                    map.on('click', layerId, (e) => {
                        if (layerId.includes('transformer')) {
                            createTransformerPopup(e);
                        } else {
                            createMeterPopup(e);
                        }
                    });

                    map.on('mouseenter', layerId, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    map.on('mouseleave', layerId, () => {
                        map.getCanvas().style.cursor = '';
                        popup.remove();
                    });
                });
            }

            // Start the dynamic configuration loading
            loadMapWithDynamicConfig();

            // Add zoom and rotation controls to the map.
            map.addControl(new mapboxgl.NavigationControl());
            
        } else {
            // If WebGL is not supported, hide the map and show the error message.
            document.getElementById('map').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('unsupported').style.display = 'flex';
        }
    });
</script>

</body>
</html>
